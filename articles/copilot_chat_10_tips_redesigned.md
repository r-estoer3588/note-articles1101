# 「Copilot、コード補完しか使えてない…」そんなあなたに贈る10の隠れた便利機能|月額の元を取る活用術

**副題:** テスト・レビュー・デバッグ・執筆を爆速化する AI 相棒との対話パターン

---

## 「またCI落ちた…」深夜0時の孤独な検索、あなただけじゃない

深夜0時、またCIが落ちた。500行のエラーログを見て、心が折れそうになる。

「なんでみんなサラッとできるんだろう…」って、検索窓に「copilot 使い方」って打ち込んでた。  
X(Twitter)で「Copilotで爆速開発!」って見るたびに、自分だけ取り残されてる気がして、夜中に一人で検索魔になってた。

その気持ち、痛いほど分かる。

私も最初は全然使いこなせなくて、Copilot に「この関数のテストを書いて」って頼んで、意味不明なテストコード(モックだらけで 80 行)が出てきて絶望した。  
月 1,000 円払ってるのに、コード補完しか使えてない自分が情けなかった。

でもね、それって **「使い方を知らなかっただけ」** だったんだよね。

あなただけじゃない。みんな最初はそうだった。  
私も3ヶ月かけて、試行錯誤しながら見つけた「隠れた便利機能10選」がある。

この記事では、開発経験1年のユイとベテランのレン先輩の対話形式で、Copilot Chat の「コード補完以外」の活用術をお伝えします。

✅ PR レビュー時間を 70%短縮  
✅ エラー対応を 3時間→5分に  
✅ テストの安定性を 2倍向上  
✅ ブログ執筆を 1時間→15分に

あなたも明日から、「Copilotの使い方教えて」って頼られる存在になれる。  
一緒に行こう。

---

## 登場人物紹介

**ユイ(開発経験1年):**  
Copilot を契約してるけど、コード補完以外の活用法が分からない。CI失敗のたびに3時間溶かして、「自分だけ遅い」と焦ってる。

**レン先輩(AI活用のベテラン):**  
Copilot を使いこなして、開発時間を 70%削減した実績を持つ。「AI は考える時間を作る道具」という哲学の持ち主。

💡 **このシリーズの特徴:**  
技術書のような堅苦しい説明ではなく、「会話」で学びます。  
実際の開発現場でのやり取りをイメージしながら読み進めてください。

---

## 機能1: 読みやすいDiff解説(修正理由の要約)

### 「300行の差分、3行で理解できたら最高じゃない?」

**ユイ:** レン先輩、今日 PR のレビュー依頼が来たんですけど、変更差分が 300 行以上あって…何が本質的な変更なのか全然分かりません。

**レン:** それはよくあるよね。リファクタとか、フォーマッタが動いた PR は特に差分が膨大になる。

**ユイ:** 先輩なら、300 行でもサクッとレビューできるんですよね…すごいです。

**レン:** いやいや、私も最初は全然できなかったよ。300行の差分を3時間かけて読んで、結局「import 文の整理だけ」だった恥ずかしさ、今でも覚えてる(笑)。

**ユイ:** え、先輩もそんな経験あるんですか!?

**レン:** あるある(笑)。でも、それから学んだんだよね。**「レビューは『全部読む』ことじゃなくて、『本質を見抜く』こと」** って。

そういうときは、Copilot Chat に Diff を貼って「この変更の要点を 3 行で要約して」って頼むといいよ。

**ユイ:** え、Diff をそのまま貼るだけでいいんですか?

**レン:** うん。GitHub の PR ページで「Files changed」タブを開いて、差分をコピペするだけ。Copilot がノイズ(インデント調整とか import の追加)と本質的な変更を分けて説明してくれる。

**ユイ:** やってみます!…あ、本当だ!「税率計算のロジック追加」「境界値テスト追加」「フォーマット調整(機能変更なし)」って整理されました!

**レン:** そう!これでレビューするべきポイントが明確になるよね。「この変更前後でテストが壊れる可能性ある?」って追加質問すると、さらにレビューの精度が上がるよ。

---

### 📝 実際のプロンプト例

```
以下の Diff の変更を 3 行で要約してください。
特に本質的な変更(ロジック・API・テストの追加/修正)に注目してください。

（※ ここに GitHub の PR ページから差分をコピー&ペーストします）
```

### 🤖 Copilot の回答例

```
1. `calculateTotal` 関数に消費税 10% の計算ロジックを追加
2. テストケースに境界値(0 円・負の値)のテストを追加
3. インデント調整と import 文の整理(機能的な変更なし)
```

---

**ユイ:** わあ、これだけで「どこを重点的に見ればいいか」が一目瞭然ですね!

**レン:** そうそう。私は、これで **PR レビュー時間を 70%削減** できたんだよね。以前は 1 件 30 分かかってたのが、今は 10 分で終わる。

**ユイ:** 70%!?すごすぎます…!

**レン:** AIは「考える時間」を作ってくれる道具なんだよ。ノイズを除外する作業は AI に任せて、君は「このロジック、本当に正しいか?」を考えることに集中できる。

**ユイ:** なるほど…私も今日のPRで試してみます!

**レン:** いいね!まずは1つだけ、3分で試してみよう。それで「お、いいじゃん!」って思えたら、明日は別の機能を試せばいい。

---

💡 **ひとこと Tips**

複雑なリファクタ PR では、**「この変更前後でテストが壊れる可能性ある?」** と追加質問すると、レビューポイントを絞り込めます。  
セキュリティ修正の場合は **「この変更で脆弱性リスクは?」** と聞くのも効果的です。

---

### 【今日のアクション】

まず今日は、手元の PR で「Diff を 3 行で要約して」と Copilot に頼んでみよう。  
3分でできる。それだけで、レビュー時間が半分になるかもしれない。

---

## 機能2: テストコード生成の叩き台(前提条件を明文化)

### 「『テスト書いて』じゃダメ。条件を絞れば精度10倍」

**ユイ:** 先輩、Copilot に「この関数のテストを書いて」って頼んだら、モックだらけの複雑なテストが出てきて逆に困りました…。

**レン:** あー、それは前提条件を明記してないから、Copilot が「念のため汎用的なテスト」を作っちゃったんだよね。

**ユイ:** あなたも今、こんな気持ちじゃない?「Copilot が作ったテスト見て『これ何してるの?』って思ったことない?」私も最初そうだった。

**レン:** そうそう。「Jest で、モック不要、境界値含めて 5 パターン」みたいに条件を絞ると、グッと精度が上がるよ。

**ユイ:** 具体的にどう聞けばいいんですか?

**レン:** こんな感じで条件を並べてみよう。

---

### ❌ 曖昧な依頼

```
この関数のテストを書いて
```

→ 結果: 不要なモック、過剰なテストケース、意図不明のアサーションが生成される

---

### ⭕ 明確な依頼

```
以下の関数のテストを書いてください。

【条件】
- テストフレームワーク: Jest
- モック: 不要(純粋関数のため)
- カバー範囲: 正常系・境界値(0, 負の値)・エラーハンドリング
- アサーション: toEqual を使用
- テストの意図をコメントで説明

（※ ここに対象の関数のコードをコピー&ペーストします）
```

→ 結果: シンプルで読みやすい、実用的なテストコードが生成される

---

**ユイ:** わあ、今度はすごくシンプルなテストが出てきました!「正常系: 税込価格の計算」とかコメントも付いてる!

**レン:** そうそう。Copilot は「どんなテストが欲しいか」を明示すると、それに合わせた精度の高いコードを生成してくれる。逆に曖昧だと、「念のため全部」になっちゃうんだよね。

**ユイ:** 「テストの意図をコメントで説明して」って追加すると、後から読んでも分かりやすいですね。

**レン:** まさに!**テストは『なぜこのテストが必要か』が分からないと、後でメンテできなくなるから**、コメント付きは実務でも重宝するよ。私は、テストコードこそ「未来の自分への手紙」だと思ってる。3ヶ月後の自分が読んで分かるように書くんだ。

**ユイ:** 未来の自分への手紙…いい言葉ですね。

**レン:** ありがとう。それが、長く続くコードを書く秘訣だと思ってる。

---

💡 **ひとこと Tips**

「エッジケース(edge case)も含めて」と追加すると、うるう年・タイムゾーン・NULL 値など、見落としがちな境界値テストも生成してくれます。

---

### 【今日のアクション】

気になった機能を、メモアプリにコピーしておくと後で役立ちます。  
「機能2:テスト生成は条件を明記」って今メモしておこう。

---

## 機能3: エラーログ要約 + 再現ステップ抽出

### 「500行のログ、5行で理解する魔法」

**ユイ:** うう…CI でテストが落ちたんですけど、ログが 500 行以上あって…どこから読めばいいか分かりません。

**レン:** スタックトレース読むの、最初は誰でも苦手だよね。私も最初、500 行のログを3時間かけて読んで、結局「testid 名の typo だけ」だった恥ずかしさ…今でも忘れられないよ(笑)。

**ユイ:** 3時間!?そんなに!?

**レン:** そう。その時、先輩に「ここに書いてあるじゃん」って言われて、めちゃくちゃ恥ずかしかった。「自分、エンジニア向いてないのかな」って落ち込んだよ。

**ユイ:** 先輩もそんな経験…!

**レン:** あるよ、みんなそうだから。でも、そこから学んだんだよね。そういうときは Copilot Chat にログを貼って「エラーの原因と再現ステップを箇条書きで」って頼むと一発だよ。

**ユイ:** え、ログ全部貼っていいんですか?長すぎて怒られませんか?

**レン:** 大丈夫、Copilot はノイズ(info ログや debug ログ)を自動で除外して、本質的なエラー部分だけ抽出してくれるから。まずは全部貼って試してみよう。

---

### 📝 実際のプロンプト例

```
以下のエラーログから、原因と再現ステップを箇条書きで抽出してください。
修正案があれば併せて提示してください。

（※ ここに CI のエラーログ全体をコピー&ペーストします）
```

---

### 🤖 Copilot の回答例

```
【エラーの原因】
- `getByTestId('submit-btn')` のセレクタが見つからない
- 原因: ボタンの data-testid 属性が `submit-button` に変更されている(PR #123 で修正)

【再現ステップ】
1. ログインページにアクセス
2. フォームにメールアドレスとパスワードを入力
3. 送信ボタンをクリック → TimeoutError 発生(5000ms で待機タイムアウト)

【修正案】
test/login.spec.ts の 15 行目を以下に修正:
`await page.getByTestId('submit-button').click();`
```

---

**ユイ:** すごい!500 行のログが 10 行でまとまりました!しかも修正案まで出てくるんですね。

**レン:** そうそう。エラーの「原因」と「再現ステップ」が分かれば、あとは修正するだけ。**「このエラーの優先度は?(高/中/低)」** って追加質問すると、どのエラーから潰すべきか判断しやすいよ。

**ユイ:** 試してみます!…「優先度: 高(全ユーザーに影響)」って出ました!これは急いで直さないと。

**レン:** いいね!エラーログ分析が速くなると、CI の失敗対応がグッと楽になるよ。**あなたも今日から、エラーログで3時間溶かす日々とサヨナラできる。私が保証する。**

**ユイ:** 心強いです!

---

💡 **ひとこと Tips**

「このエラーの優先度は?(高/中/低)」と追加質問すると、どのエラーから潰すべきか判断しやすくなります。  
また、「過去に似たエラーはあった?」と聞くと、既知の問題かどうかの手がかりが得られます。

---

### 【今日のアクション】

今日のプロジェクトで、機能3(エラーログ要約)を試してみませんか?  
CI が落ちたら、ログを Copilot に貼るだけ。5分で原因が分かるかも。

---

## 機能4: セレクタ改善アドバイス(role/testid 優先)

### 「class名で指定してた過去の自分、ごめん」

**ユイ:** 先輩、Playwright のセレクタを class 名で指定してたら、デザイン変更のたびに CI が壊れて大変でした…。

**レン:** あー、それはよくあるミスだね。class 名やテキストは変更に弱いから、本番環境では避けた方がいい。Copilot Chat にコードを貼って「セレクタを改善して」って頼むと、`getByRole` や `getByTestId` を提案してくれるよ。

**ユイ:** どっちを使えばいいんですか?

**レン:** まずは `getByRole` を優先してみよう。アクセシビリティにも配慮できるし、HTML の意味構造に沿ったセレクタだから壊れにくい。ただし、複数の同じ role がある場合は `getByTestId` で明確に指定する感じだね。

---

### 📝 実際のプロンプト例

```
以下の Playwright コードのセレクタを改善してください。
- class 名やテキストベースのセレクタは避ける
- getByRole または getByTestId を優先
- アクセシビリティを考慮

（※ ここに改善したい Playwright のテストコードをコピー&ペーストします）
```

---

### ❌ 改善前(壊れやすいセレクタ)

```javascript
// class名に依存 → デザイン変更で壊れる
await page.locator(".btn-primary").click();

// テキストに依存 → 多言語対応で壊れる
await page.locator("text=送信").click();
```

---

### ⭕ 改善後(安定したセレクタ)

```javascript
// role指定 → アクセシビリティ◎、壊れにくい
await page.getByRole("button", { name: "送信" }).click();

// testid指定 → 明確、テスト専用属性で安全
await page.getByTestId("submit-btn").click();
```

---

**ユイ:** すごい!`getByRole` を使うと、スクリーンリーダーでの読み上げも改善されるんですね。

**レン:** そうそう!**テストの安定性とアクセシビリティが同時に向上するから一石二鳥** だよ。「このページのアクセシビリティを改善するセレクタを提案して」って追加質問すると、WAI-ARIA 対応の role 指定も学べるよ。

**ユイ:** テストって、「壊れないこと」が大事なんですね。

**レン:** まさに。私は、**速さより安定性を優先する。それが長く続く秘訣** だと思ってる。一時的に速くても、メンテで苦しむのは嫌だから。

---

💡 **ひとこと Tips**

「このページのアクセシビリティを改善するセレクタを提案して」と追加質問すると、WAI-ARIA 対応の role 指定を学べます。  
また、「複数の同じ role がある場合の対処法は?」と聞くと、`name` や `level` での絞り込み方法も分かります。

---

## 機能5: 待機戦略の提案(固定 sleep から条件待ちへ)

### 「固定sleep、もうやめよう。条件待ちで高速&安定」

**ユイ:** うーん、Playwright で「要素が見つかりません」エラーが頻発します…待機時間を増やせば解決しますかね?

**レン:** 単純に `await page.waitForTimeout(5000)` とかで固定待機すると、テストが遅くなる上に、それでも落ちるときがあるんだよね。

**ユイ:** え、固定待機がダメなんですか!?

**レン:** ダメじゃないけど、最終手段だね。私も最初、固定待機で CI が不安定になって、「自分のテスト下手くそ」って落ち込んだ。でも、条件待ちに変えたら一発で解決したんだよ。

**ユイ:** 条件待ち…?

**レン:** Copilot Chat に「この操作の適切な待機戦略を教えて」って頼むと、状況に応じた `waitForSelector` の使い分けを提案してくれるよ。

---

### 📝 実際のプロンプト例

```
以下の Playwright コードで「要素が見つかりません」エラーが発生します。
適切な待機戦略(waitForSelector の state 指定)を提案してください。

（※ ここにエラーが発生している Playwright のコードをコピー&ペーストします）
```

---

### ❌ 改善前(固定待機で遅い)

```javascript
// 5秒固定待機 → 速い環境でも遅い、遅い環境では足りない
await page.waitForTimeout(5000);
await page.locator("#result").click();
```

---

### ⭕ 改善後(条件待ちで高速＆安定)

```javascript
// API通信後に表示される要素なので、visible待ちを追加
await page.waitForSelector("#result", { state: "visible" });
await page.locator("#result").click();

// またはgetByRole系なら自動で待機してくれる(推奨)
await page.getByRole("button", { name: "結果を表示" }).click();
```

---

**ユイ:** あ、`state: "visible"` と `state: "attached"` って何が違うんですか?

**レン:** いい質問!`attached` は DOM に存在すれば OK、`visible` は画面に見えている状態まで待つ。アニメーションで徐々に表示される要素は `visible` を使うと確実だよ。

**ユイ:** なるほど!試してみます!

**レン:** **あなたもできる。私ができたんだから、絶対できる。** まずは API 通信が絡む要素から試してみよう。

---

💡 **ひとこと Tips**

「この待機は state: 'visible' と state: 'attached' のどちらが適切?」と追加質問すると、シーン別の使い分けを学べます。  
また、「並列実行時の待機戦略は?」と聞くと、テスト分離のベストプラクティスも分かります。

---

## 機能6: 設定ファイル・定型コードのテンプレート生成

### 「公式ドキュメントの200行、5秒で最小構成に」

**ユイ:** Playwright の設定ファイル、公式ドキュメントのサンプルが 200 行以上あって…何が必須なのか全然分かりません!

**レン:** それ、Copilot Chat に「Playwright の最小構成の playwright.config.ts を作って」って頼むと、必須項目だけのテンプレを出してくれるよ。オプション設定は後から追加すればいいから、まずはシンプルに始めよう。

**ユイ:** え、そんな簡単に作れるんですか!?

**レン:** うん。**最初から完璧を目指さなくていい。まずは動く最小構成を作って、必要になったら足していく。それが挫折しない秘訣** だよ。私も、いきなり完璧を目指して何度も挫折したから、この教訓は身に染みてる(笑)。

---

### 📝 実際のプロンプト例

```
Playwright の最小構成の playwright.config.ts を作成してください。

【要件】
- ブラウザ: Chromium のみ
- ヘッドレスモード
- レポート: HTML 形式
- 並列実行: 4 workers
- 不要なオプションは除外
```

---

### 🤖 Copilot の回答例

```typescript
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  fullyParallel: true,
  workers: 4,
  reporter: "html",
  use: {
    headless: true,
    viewport: { width: 1280, height: 720 },
    screenshot: "only-on-failure",
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
});
```

---

**ユイ:** わあ、こんなにシンプルになりました!これなら読めます!

**レン:** そうでしょ?あとで「この設定に CI 用の最適化を追加して」って追加依頼すると、`retries: 2` とかタイムアウト延長も提案してくれるよ。必要になったら段階的に拡張していけばいい。

**ユイ:** 段階的に拡張!それなら迷わなくて済みますね。

**レン:** そう。**私は、「動けばいい」じゃなくて、「3ヶ月後の自分が読んでも分かる」コードを目指してる。未来の自分への優しさだと思ってる** んだ。

---

💡 **ひとこと Tips**

「この設定に CI 用の最適化を追加して」と追加依頼すると、`retries: 2`、タイムアウト延長、ビデオ録画の設定を提案してくれます。  
また、「GitHub Actions で実行する設定は?」と聞くと、CI 専用の環境変数設定も分かります。

---

## 機能7: リファクタリング提案(可読性 UP)

### 「120行の関数、10行×6個に分割してスッキリ」

**ユイ:** 先輩、この関数 120 行もあって…読みにくいし、どう分割すればいいか分かりません。

**レン:** それ、Copilot Chat に「この関数をリファクタして」って頼むと、適切な粒度で関数を分割してくれるよ。「Single Responsibility Principle(単一責任の原則)を守って」と追加すると、より洗練された構造になる。

**ユイ:** 単一責任の原則…?

**レン:** 「1 つの関数は 1 つの仕事だけする」ってルールだよ。たとえば、バリデーション・計算・保存・通知を 1 つの関数でやってるなら、それぞれ独立した関数に分けた方が、テストもメンテもしやすくなる。

---

### 📝 実際のプロンプト例

```
以下の関数をリファクタしてください。

【条件】
- 関数を適切な粒度で分割
- 単一責任の原則を守る
- 元の動作は変えない
- 各関数の責務をコメントで説明

（※ ここにリファクタしたい長い関数のコードをコピー&ペーストします）
```

---

### ❌ Before: 120 行の巨大関数

```javascript
async function processOrder(order) {
  // バリデーション(20行)
  if (!order.items || order.items.length === 0) throw new Error("...");
  // ...

  // 計算(30行)
  let total = 0;
  for (const item of order.items) {
    total += item.price * item.quantity;
  }
  // ...

  // 保存(40行)
  const connection = await db.connect();
  // ...

  // 通知(30行)
  await sendEmail(order.email, "注文確認");
  // ...
}
```

---

### ⭕ After: 役割ごとに分割(読みやすい!)

```javascript
// メイン処理:各ステップをオーケストレーション
async function processOrder(order) {
  const validated = validateOrder(order);
  const calculated = calculateTotal(validated);
  const saved = await saveToDatabase(calculated);
  await sendNotification(saved);
  return saved;
}

// バリデーション責務
function validateOrder(order) {
  if (!order.items || order.items.length === 0) {
    throw new Error("商品が選択されていません");
  }
  return order;
}

// 計算責務
function calculateTotal(order) {
  const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  return { ...order, total };
}

// 保存責務
async function saveToDatabase(order) {
  const connection = await db.connect();
  const saved = await connection.orders.insert(order);
  await connection.close();
  return saved;
}

// 通知責務
async function sendNotification(order) {
  await sendEmail(order.email, `注文確認: ${order.total}円`);
}
```

---

**ユイ:** わあ!各関数が 10 行以内になって、何をしてるか一目で分かります!

**レン:** そうでしょ?これで「calculateTotal だけテストしたい」ってときも、独立した関数だから簡単にテストできる。「このリファクタで追加すべきテストケースは?」って追加質問すると、境界値や例外ケースを洗い出してくれるよ。

**ユイ:** リファクタと同時にテストも充実させられるんですね!一石二鳥!

**レン:** そう。**私は、リファクタを『負債返済』じゃなくて、『未来への投資』だと思ってる** んだ。今ちょっと時間かけて整理しておけば、3ヶ月後の自分が楽になる。

---

💡 **ひとこと Tips**

「このリファクタで追加すべきテストケースは?」と追加質問すると、境界値や例外ケースを洗い出せます。  
また、「この関数の複雑度(Cyclomatic Complexity)は?」と聞くと、さらなる改善ポイントが見つかります。

---

## 機能8: テストデータ設計の叩き台

### 「正常系だけじゃダメ!境界値を網羅してバグ検出率3倍」

**ユイ:** 先輩、テストデータって「正常系 1 パターン」だけ書いておけば大丈夫ですよね…?

**レン:** それだとバグ見逃す可能性がめちゃくちゃ高いよ!Copilot Chat に「この関数の境界値と同値分割を教えて」って頼むと、網羅すべきテストケースを一覧で出してくれる。

**ユイ:** 境界値…?同値分割…?

**レン:** たとえば、「5000 円以上で割引」って条件なら、4999 円(境界値の直前)、5000 円(境界値)、5001 円(境界値の直後)の 3 パターンをテストするんだよ。それが境界値分析。同値分割は「同じ振る舞いをする範囲をグループ化」する手法だね。

---

### 📝 実際のプロンプト例

```
以下の関数のテストケースを、境界値分析と同値分割の手法で網羅的に列挙してください。

function calculateDiscount(price, userType) {
  if (price < 0) throw new Error('Invalid price');
  if (price >= 10000 && userType === 'premium') return price * 0.8;
  if (price >= 5000) return price * 0.9;
  return price;
}
```

---

### 🤖 Copilot の回答例

```
【境界値】
- price: -1, 0, 1, 4999, 5000, 5001, 9999, 10000, 10001
- userType: 'premium', 'normal', null, undefined

【同値分割】
1. price < 0 → エラー
2. 0 <= price < 5000 → 割引なし
3. 5000 <= price < 10000 → 10% 割引
4. price >= 10000 && userType === 'premium' → 20% 割引
5. price >= 10000 && userType !== 'premium' → 10% 割引

【推奨テストケース(11 パターン)】
| price  | userType  | 期待結果           |
|--------|-----------|-------------------|
| -1     | 'normal'  | Error             |
| 0      | 'normal'  | 0                 |
| 4999   | 'normal'  | 4999              |
| 5000   | 'normal'  | 4500 (10%割引)    |
| 5001   | 'premium' | 4500.9            |
| 9999   | 'premium' | 8999.1            |
| 10000  | 'premium' | 8000 (20%割引)    |
| 10001  | 'premium' | 8000.8            |
| 10000  | 'normal'  | 9000 (10%割引)    |
| 5000   | null      | 4500              |
| 10000  | undefined | 9000              |
```

---

**ユイ:** わあ、正常系だけだと思ってたのに、こんなに必要だったんですね!

**レン:** そうそう。境界値はバグが潜みやすいポイントだから、必ずテストすべき。「このテストケースを Jest の test.each で書いて」って追加依頼すると、パラメタライズドテストのコードまで生成してくれるよ。

**ユイ:** やってみます!…あ、test.each で 11 パターンが一気に書けました!すごい!

**レン:** いいね!**境界値分析、難しそうに聞こえるけど、Copilot に聞けば一発だから。あなたも今日から、バグを未然に防げる。**

---

💡 **ひとこと Tips**

「このテストケースを Jest の test.each で書いて」と追加依頼すると、パラメタライズドテストのコードを生成してくれます。  
また、「うるう年の境界値は?」と聞くと、日付関連の複雑なエッジケースも洗い出せます。

---

## 機能9: CIログの失敗原因分類

### 「3つの失敗、実は1つの根本原因だった」

**ユイ:** うわー、CI で 3 つのテストが同時に落ちました…全部別々に調査するのしんどいです。

**レン:** それ、Copilot Chat にログを貼って「失敗原因を環境・時間・データの観点で分類して」って頼むと、共通の根本原因を見つけやすくなるよ。

**ユイ:** 環境・時間・データ…?

**レン:** そう。たとえば「環境起因」ならブラウザのバージョン違い、「時間起因」ならタイムアウトやタイミング依存、「データ起因」ならテストデータ不足とか。分類すると「実は全部タイムアウトが原因だった」みたいに、1 つの対処で複数のテストが直ることがあるんだよ。

**ユイ:** なるほど!効率的ですね!

**レン:** 私も最初、3つのテストを別々に調査して、丸1日溶かした。でも分類すれば、30分で終わることを学んだんだよね。

---

### 📝 実際のプロンプト例

```
以下の CI ログから、テスト失敗の原因を以下の観点で分類してください。

【分類軸】
- 環境起因(OS/ブラウザ/依存ライブラリのバージョン違い)
- 時間起因(タイムアウト/タイミング依存/並列実行の競合)
- データ起因(テストデータ不足/不正/DB 状態の問題)

（※ ここに CI のエラーログ全体をコピー&ペーストします）
```

---

### 🤖 Copilot の回答例

```
【環境起因】
- Test A: Chromium 120 で font-family のレンダリングが期待値と異なる
  → スクリーンショット比較が失敗(Ubuntu と macOS で差異)

【時間起因】
- Test B: API 通信が 3 秒以上かかり、デフォルトタイムアウト(5 秒)に引っかかる
  → 原因: 外部 API のレスポンス遅延
- Test C: 並列実行時に DB ロックが発生
  → 原因: トランザクション分離レベルの設定不足

【データ起因】
- なし(今回のログでは該当なし)

【推奨対応(優先度順)】
1. Test B(高): API 通信の明示的待機を 10 秒に延長、またはモック化検討
2. Test C(高): テスト分離(各テストで独立した DB インスタンスを使用)
3. Test A(中): スクリーンショット比較の threshold を 0.1 → 0.2 に緩和
```

---

**ユイ:** すごい!3 つのテストが全部「時間起因」と「環境起因」に分類されました!

**レン:** そう!Test B と C は両方「時間」の問題だから、待機戦略を見直せば 2 つ同時に解決できる可能性が高い。「この 3 つの失敗、優先度順に並べて」って追加質問すると、どれから潰すべきか一目瞭然だよ。

**ユイ:** やってみます!…「Test B を先に直せば、Test C も間接的に改善する可能性あり」って出ました!効率的!

**レン:** いいね!**あなたも今日から時間を取り戻せる。私も応援してる。**

---

💡 **ひとこと Tips**

「この 3 つの失敗、優先度順に並べて」と追加質問すると、どのテストから潰すべきか一目瞭然です。  
また、「過去 1 週間で似た失敗はあった?」と聞くと、繰り返し発生する問題の傾向が分かります。

---

## 機能10: ドキュメント・コメント執筆の補助

### 「箇条書きメモが、記事に変身する魔法」

**ユイ:** 先輩、技術ブログ書きたいんですけど…箇条書きメモから記事にするのが苦手で、構成が思いつきません。

**レン:** それ、Copilot Chat に箇条書きメモを貼って「この内容を記事の章立てにして」って頼むと、序論 → 本論 → 結論の流れを自動で作ってくれるよ。そのあと「各章を 300 字で執筆して」と追加依頼すれば、一気に仕上がる。

**ユイ:** え、そんな簡単に記事が書けるんですか!?

**レン:** うん。重要なのは「誰に」「何を」伝えたいかを明確にすること。読者層と目的を指定すれば、Copilot が適切なトーンと構成を提案してくれる。

**ユイ:** なるほど!

**レン:** 私は、**アウトプットすることで自分の理解を深めたい。だから、学んだことは必ず記事にする。Copilot はその『言語化』を手伝ってくれる最高の相棒** なんだ。

---

### 📝 実際のプロンプト例(ステップ 1: 章立て生成)

```
以下の箇条書きメモを、技術ブログ記事の章立てに変換してください。

【想定読者】
- Playwright 初心者(使い始めて 1-3 ヶ月)

【目的】
- CI 失敗の原因と対処法を理解してもらう

【内容メモ】
- タイムアウトが頻発する原因と対策
- セレクタが壊れる理由(class 名 vs role)
- ローカル OK・CI NG の環境差異
- 並列実行時の競合問題

（※ ここに箇条書きメモをコピー&ペーストします）
```

---

### 🤖 Copilot の回答例

```
【タイトル案】
Playwright の CI 失敗を 30 分で潰す実践ガイド

【章立て】
1. はじめに(CI で困ってませんか?)
2. 失敗パターン 1: タイムアウト地獄から脱出
3. 失敗パターン 2: セレクタが突然壊れる理由
4. 失敗パターン 3: ローカル OK・CI NG の謎
5. 失敗パターン 4: 並列実行で競合が発生
6. まとめ(30 分で安定 CI を実現しよう)

【各章の要点】
- 第 1 章: 読者の共感を得る導入(「あるある」を列挙)
- 第 2 章: 固定待機 vs 条件待機の違い
- 第 3 章: getByRole の安定性を説明
- 第 4 章: 環境差異(フォント/スクリーンサイズ)
- 第 5 章: トランザクション分離の重要性
- 第 6 章: 10 個のチェックリストで復習
```

---

### 📝 ステップ 2: 執筆支援

```
「2. 失敗パターン 1: タイムアウト地獄から脱出」の章を 300 字で執筆してください。

【条件】
- 初心者にも分かりやすく
- 対話形式(質問→回答)
- 具体例を含める
```

---

### 🤖 Copilot の回答例

```
## 失敗パターン 1: タイムアウト地獄から脱出

ユイ: CI で「TimeoutError: waiting for selector...」がよく出るんですけど、どうすればいいですか?

レン: それ、固定待機(`waitForTimeout`)を使ってない?条件待機(`waitForSelector`)に変えると劇的に改善するよ。

たとえば、API 通信後に表示される要素なら:

// ❌ 固定待機: 遅い＆不安定
await page.waitForTimeout(5000);

// ⭕ 条件待機: 速い＆安定
await page.waitForSelector("#result", { state: "visible" });

ユイ: なるほど!「要素が見えるまで待つ」の方が確実ですね。

レン: その通り。これで環境が速ければ 1 秒、遅くても必要な分だけ待つから、無駄がない。
```

---

**ユイ:** わあ!章立ても本文も、あっという間にできました!

**レン:** そうでしょ?最後に「この記事の要約を 50 字で」って追加依頼すると、X 投稿用のキャッチコピーも生成できるよ。

**ユイ:** やってみます!…「Playwright の CI 失敗を 30 分で潰す 4 つの実践パターン。タイムアウト・セレクタ・環境差異・並列競合を対話形式で解決。」って出ました!そのまま使えそう!

**レン:** いいね!**あなたも今日学んだことを、X(Twitter)で 140 字でシェアしてみよう。それだけでアウトプットの第一歩だから。**

---

💡 **ひとこと Tips**

「この記事の要約を 50 字で」と追加依頼すると、X 投稿用のキャッチコピーを生成できます。  
また、「この記事の SEO キーワードを 5 つ抽出して」と聞くと、検索流入を狙ったタグ設定も楽になります。

---

### 【今日のアクション】

成果が出たら、ぜひ **#Copilot活用術** でシェアしてください。  
あなたの「できた!」が、誰かの勇気になります。

---

## まとめ: 3ヶ月後のあなたは、「あの時やっててよかった」って思ってる

10 の機能を使えば、

✅ PR レビュー時間 70%削減  
✅ エラー対応 3時間→5分  
✅ テストの安定性 2倍向上  
✅ ブログ執筆 1時間→15分

3ヶ月後、あなたは「あの時やっててよかった」って思ってる。  
周りから「Copilotの使い方教えて」って頼られる存在になってる。

まず今日は、**機能1だけ試してみよう**。3分でできる。  
それで「お、いいじゃん!」って思えたら、明日は機能2を試せばいい。

**一気に10個やらなくていい。1個ずつ、あなたのペースで。**

私も最初は、あなたと同じだった。  
でも、一歩ずつ進んだら、今では Copilot が手放せない相棒になった。

あなたも絶対できる。だって、ここまで読んでくれたんだから。

さあ、今日から一緒に。私も応援してる📣

---

## 最後の会話

**レン:** ユイ、今日で Copilot Chat の隠れた便利機能 10 個が分かったね。どう、使ってみたくなった?

**ユイ:** はい!特に「エラーログ分析」と「境界値分析」は明日から使います!今まで手作業でやってたことが、一瞬で終わるなんて…感動です。

**レン:** いいね!重要なのは「何をしたいか」を明確に伝えることだよ。技術的な実装は AI が助けてくれるから、君は「どんな問題を解決したいか」に集中できる。

**ユイ:** そっか、**AI は『考える時間』を作ってくれるんですね**。デバッグに追われる時間が減れば、もっと設計とか新機能の開発に時間を使えそうです。

**レン:** その通り。これからはもっと進化して、AI が自動でコードレビューしたり、バグを予測したりする時代が来るよ。今のうちに AI との付き合い方を学んでおくと、すごく武器になる。

**ユイ:** 楽しみです!まずは今日教えてもらった 10 の機能を、自分のプロジェクトで 1 つずつ試してみます。困ったらまた Copilot Chat に聞けばいいんですもんね。

**レン:** そうそう!Copilot は 24 時間働いてくれる最高の相棒だから。がんばってね。

**ユイ:** ありがとうございました!😊

---

## あなたへのメッセージ

この記事をここまで読んでくれたあなたへ。

あなたは、「成長したい」「変わりたい」って気持ちがあるから、この記事を開いてくれたんだよね。  
その気持ちがある限り、絶対に伸びる。私が保証する。

今日のメモから始めよう。  
「機能1:Diff要約」ってメモするだけでいい。

それだけで、明日のあなたは今日のあなたより速くなってる。

大丈夫、あなたもできるから。一緒にやろ。

私も応援してる📣

---

## 次回予告 📢

次回は、今回の「機能 9: CI ログの失敗原因分類」を実践編に展開します。

**【対話で学ぶ】Playwright の CI 失敗を 30 分で潰す実践ガイド**

- タイムアウト・セレクタ・環境差異・並列競合を対話形式で解決
- Before/After ログ比較で改善ポイントが一目瞭然
- 実務で使える 10 個のチェックリスト付き

公開予定: 近日公開

続編の通知がほしい方は、ぜひ ❤️ やフォローで教えてください!

---

## シリーズ記事一覧

- **Week 1:** [Copilot Chat の隠れた便利機能 10 選] ← 今ここ
- **Week 2:** CI 失敗を 30 分で潰す実践ガイド(近日公開)
- **Week 3:** 落ちないテスト設計の実践(近日公開)
- **Week 4:** AI × E2E の運用設計(近日公開)

---

## 💬 質問・感想はコメント欄で大歓迎です!

🐦 X(Twitter)で感想をシェアいただけると嬉しいです: @ai_narrative25

🏷️ **Tags (note 用表示)**

#GitHubCopilot #CopilotChat #AI支援開発 #Playwright #テスト自動化 #開発効率化 #リファクタリング #ログ解析 #エンジニア #技術ブログ

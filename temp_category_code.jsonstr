"// Categorize note with OpenAI when possible and provide fallback heuristics\nconst inputData = $input.item.json;\nconst apiKey = $env.OPENAI_API_KEY;\n\nconst buildFallback = () => {\n  const text = `${inputData.fileName || ''}\\n${inputData.fileContent || ''}`.toLowerCase();\n  const pathLower = (inputData.filePath || '').toLowerCase();\n  const tagsSet = new Set();\n\n  const segments = (inputData.filePath || '')\n    .split('/')\n    .map(segment => segment.trim())\n    .filter(Boolean);\n\n  // Use folder names as tags when available\n  segments.slice(0, -1).forEach(segment => tagsSet.add(segment));\n\n  const rules = [\n    { pattern: /(meeting|\u8b70\u4e8b\u9332|\u4f1a\u8b70|mtg)/i, category: '\u4f1a\u8b70\u30e1\u30e2', tags: ['\u4f1a\u8b70'] },\n    { pattern: /(reading|\u8aad\u66f8|\u66f8\u8a55|\u8981\u7d04)/i, category: '\u8aad\u66f8\u30e1\u30e2', tags: ['\u8aad\u66f8'] },\n    { pattern: /(idea|\u30a2\u30a4\u30c7\u30a2|\u4f01\u753b|brainstorm)/i, category: '\u30a2\u30a4\u30c7\u30a2', tags: ['\u30a2\u30a4\u30c7\u30a2'] },\n    { pattern: /(todo|task|\u65e5\u5831|\u632f\u308a\u8fd4\u308a|\u5b66\u7fd2|\u30e1\u30e2)/i, category: '\u500b\u4eba\u30e1\u30e2', tags: ['\u30e1\u30e2'] },\n    { pattern: /(code|\u958b\u767a|python|bug|\u6280\u8853|sql|api)/i, category: '\u6280\u8853\u30e1\u30e2', tags: ['\u6280\u8853'] }\n  ];\n\n  for (const rule of rules) {\n    if (rule.pattern.test(text) || rule.pattern.test(pathLower)) {\n      if (Array.isArray(rule.tags)) {\n        rule.tags.forEach(tag => tagsSet.add(tag));\n      }\n      return {\n        category: rule.category,\n        tags: Array.from(tagsSet)\n      };\n    }\n  }\n\n  if (segments.length > 1) {\n    const folder = segments[segments.length - 2] || '\u672a\u5206\u985e';\n    tagsSet.add(folder);\n    return {\n      category: folder,\n      tags: Array.from(tagsSet)\n    };\n  }\n\n  return {\n    category: '\u672a\u5206\u985e',\n    tags: Array.from(tagsSet)\n  };\n};\n\nconst mergeResult = result => {\n  const category = result.category || '\u672a\u5206\u985e';\n  const tags = Array.isArray(result.tags) ? result.tags : [];\n  const uniqueTags = Array.from(new Set(tags.map(tag => String(tag).trim()).filter(Boolean)));\n  return { ...inputData, category, tags: uniqueTags };\n};\n\nif (!apiKey) {\n  return mergeResult(buildFallback());\n}\n\ntry {\n  const response = await $http.post('https://api.openai.com/v1/chat/completions', {\n    model: 'gpt-4o-mini',\n    messages: [\n      {\n        role: 'user',\n        content: `\u3042\u306a\u305f\u306f\u30ce\u30fc\u30c8\u5206\u985e\u306e\u5c02\u9580\u5bb6\u3067\u3059\u3002\u4ee5\u4e0b\u306e\u30ce\u30fc\u30c8\u5185\u5bb9\u3092\u8aad\u3093\u3067\u3001\u9069\u5207\u306a\u30ab\u30c6\u30b4\u30ea\u3068\u30bf\u30b0\u3092\u63d0\u6848\u3057\u3066\u304f\u3060\u3055\u3044\u3002\\n\\n\u3010\u30ab\u30c6\u30b4\u30ea\u5019\u88dc\u3011\\n- \u6280\u8853\u30e1\u30e2\\n- \u8aad\u66f8\u30e1\u30e2\\n- \u30a2\u30a4\u30c7\u30a2\\n- \u4f1a\u8b70\u30e1\u30e2\\n- \u500b\u4eba\u30e1\u30e2\\n\\n\u3010\u51fa\u529b\u5f62\u5f0f\u3011\\nJSON\u5f62\u5f0f\u3067\u8fd4\u3057\u3066\u304f\u3060\u3055\u3044:\\n{\"category\": \"\u30ab\u30c6\u30b4\u30ea\u540d\", \"tags\": [\"\u30bf\u30b01\"]}\\n\\n\u30d5\u30a1\u30a4\u30eb\u540d: ${inputData.fileName}\\n\u5185\u5bb9: ${inputData.fileContent}`\n      }\n    ],\n    temperature: 0.3,\n    response_format: { type: 'json_object' }\n  }, {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json'\n    }\n  });\n\n  const content = response.data.choices?.[0]?.message?.content;\n  if (!content) {\n    return mergeResult(buildFallback());\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(content);\n  } catch (parseError) {\n    console.error('OpenAI parse error:', parseError.message);\n    return mergeResult(buildFallback());\n  }\n\n  const fallback = buildFallback();\n  const category = parsed.category || fallback.category;\n  const combinedTags = new Set();\n  (fallback.tags || []).forEach(tag => combinedTags.add(String(tag)));\n  (Array.isArray(parsed.tags) ? parsed.tags : []).forEach(tag => combinedTags.add(String(tag)));\n\n  return {\n    ...inputData,\n    category: category || '\u672a\u5206\u985e',\n    tags: Array.from(combinedTags).map(tag => tag.trim()).filter(Boolean)\n  };\n} catch (error) {\n  console.error('OpenAI API Error:', error.message);\n  return mergeResult(buildFallback());\n}\n"
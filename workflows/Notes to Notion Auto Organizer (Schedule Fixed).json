{
  "name": "Notes to Notion Auto Organizer (Schedule Fixed)",
  "nodes": [
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true
          },
          "conditions": [
            {
              "id": "f1234567-890a-bcde-f123-4567890abcde",
              "leftValue": "={{ $now.minus({ days: 30 }).toMillis() }}",
              "rightValue": "={{ new Date($json.createdDate).getTime() }}",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ae4c08cc-84f4-4343-974f-a6065d98f894",
      "name": "Old File Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -736,
        -336
      ]
    },
    {
      "parameters": {
        "command": "=rm -f \"{{ $json.filePath }}\""
      },
      "id": "c083adc7-5345-4b39-a407-c43f69fe2066",
      "name": "Delete Old File",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -528,
        -352
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "id": "f668417f-4ddc-432b-915f-2ad6f8f5bef0",
      "name": "Daily Reminder Cron",
      "type": "n8n-nodes-base.scheduleTrigger",
  "typeVersion": 1,
      "position": [
        -1920,
        -128
      ]
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "29e1972f485180c89c68d77f1b82e39f",
          "mode": "id"
        },
        "returnAll": true,
        "options": {}
      },
      "id": "76478e0e-3ab4-4249-9748-fd6a594f6d76",
      "name": "Get All Notes from Notion",
      "type": "n8n-nodes-base.notion",
  "typeVersion": 2,
      "position": [
        -1728,
        -128
      ],
      "credentials": {
        "notionApi": {
          "id": "nsXTOjwR6MmTqoxn",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pick random note for reminder\nconst items = $input.all();\nconst randomIndex = Math.floor(Math.random() * items.length);\nconst randomNote = items[randomIndex].json;\n\nreturn {\n  title: randomNote.properties?.Title?.title?.[0]?.plain_text || 'No title',\n  url: randomNote.url,\n  category: randomNote.properties?.Category?.rich_text?.[0]?.plain_text || '未分類'\n};"
      },
      "id": "00734a7a-b999-4b8d-b242-ca30fdb17eac",
      "name": "Random Reminder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1536,
        -128
      ]
    },
    {
      "id": "ab7a5330-e706-49a3-a3c3-f3cee5c69731",
      "name": "Schedule Trigger1",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        -1920,
        -528
      ]
    },
    {
      "parameters": {
        "command": "find /notes -type f \\( -name \"*.txt\" -o -name \"*.md\" \\) ! -name \".processed_files.txt\""
      },
      "id": "674e88fa-f8a7-4a25-8bd9-1718b4afa2d8",
      "name": "List All Files1",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -1728,
        -528
      ]
    },
    {
      "parameters": {
        "command": "touch /notes/.processed_files.txt && cat /notes/.processed_files.txt"
      },
      "id": "1a9d5c56-61dd-4fb4-9e6c-db4c3a580474",
      "name": "Get Processed List1",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -1728,
        -400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Filter out already processed files\n// Robust strategy when upstream Execute Command nodes do NOT include the command string.\n// We receive two items: one is file list (find), the other is processed list (cat).\n// Choose the longer stdout as all files; the remaining as processed list.\n\nconst inputs = $input.all();\nconst stdouts = inputs.map(i => String(i.json?.stdout || '')).map(s => s.trim());\n\nlet allFilesOutput = '';\nlet processedListOutput = '';\n\nif (stdouts.length === 0) {\n  return [];\n} else if (stdouts.length === 1) {\n  // Only file list likely arrived; proceed with empty processed list\n  allFilesOutput = stdouts[0];\n} else {\n  // Pick the one with more lines/length as all files\n  const withCounts = stdouts.map((s, idx) => ({ idx, s, lines: s.split(/\\r?\\n/).filter(Boolean).length, len: s.length }));\n  withCounts.sort((a,b) => (b.lines - a.lines) || (b.len - a.len));\n  allFilesOutput = withCounts[0].s;\n  // The other (first non-identical) is processed list\n  const other = withCounts.find(x => x.s !== allFilesOutput);\n  processedListOutput = other ? other.s : '';\n}\n\nallFilesOutput = allFilesOutput.trim();\nprocessedListOutput = processedListOutput.trim();\n\nif (!allFilesOutput) {\n  return [];\n}\n\nconst allFiles = allFilesOutput.split(/\\r?\\n/).map(s => s.trim()).filter(Boolean);\nconst processedFiles = processedListOutput ? processedListOutput.split(/\\r?\\n/).map(s => s.trim()).filter(Boolean) : [];\nconst processedSet = new Set(processedFiles);\n\nconst unprocessedFiles = allFiles.filter(f => !processedSet.has(f));\nif (unprocessedFiles.length === 0) {\n  return [];\n}\n\nreturn unprocessedFiles.map(file => ({ json: { path: file, fileName: file.split('/')?.pop() } }));"
      },
      "id": "db5c969d-4869-4e00-a26b-d0f2604e5ab9",
      "name": "Filter Unprocessed Files1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        -528
      ]
    },
    {
      "parameters": {
        "filePath": "={{ $json.path }}"
      },
      "id": "8e2d7efc-1e11-442e-97a6-405f75e48a2e",
      "name": "Read Note File1",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        -1152,
        -528
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract UTF-8 text content from binary produced by Read Binary File\nconst item = $input.item;\nconst path = item.json.path;\nconst fileName = (item.json.fileName || (path ? path.split('/').pop() : 'Untitled'));\n\nlet fileContent = '';\nif (item.binary) {\n  let base64Str = '';\n  if (typeof item.binary.data === 'string') {\n    base64Str = item.binary.data;\n  } else if (item.binary.data && typeof item.binary.data.data === 'string') {\n    base64Str = item.binary.data.data;\n  } else {\n    const firstKey = Object.keys(item.binary)[0];\n    const entry = item.binary[firstKey];\n    if (entry && typeof entry.data === 'string') {\n      base64Str = entry.data;\n    } else if (entry && entry.data && typeof entry.data.data === 'string') {\n      base64Str = entry.data.data;\n    }\n  }\n  if (base64Str) {\n    try {\n      fileContent = Buffer.from(base64Str, 'base64').toString('utf8');\n    } catch (e) {\n      fileContent = base64Str;\n    }\n  }\n}\n\nreturn { fileName, fileContent, filePath: path, createdDate: new Date().toISOString() };",
        "mode": "runOnceForEachItem"
      },
      "id": "224f20fd-ff8f-4a8f-97a9-5429829e901c",
      "name": "Set Note Metadata1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        -528
      ]
    },
    {
      "parameters": {
  "jsCode": "// Categorize note with OpenAI when possible and provide fallback heuristics\nconst inputData = $input.item.json;\nconst apiKey = $env.OPENAI_API_KEY;\n\nconst buildFallback = () => {\n  const text = `${inputData.fileName || ''}\\n${inputData.fileContent || ''}`.toLowerCase();\n  const pathLower = (inputData.filePath || '').toLowerCase();\n  const tagsSet = new Set();\n\n  const segments = (inputData.filePath || '')\n    .split('/')\n    .map(segment => segment.trim())\n    .filter(Boolean);\n\n  // Use folder names as tags when available\n  segments.slice(0, -1).forEach(segment => tagsSet.add(segment));\n\n  const rules = [\n    { pattern: /(meeting|議事録|会議|mtg)/i, category: '会議メモ', tags: ['会議'] },\n    { pattern: /(reading|読書|書評|要約)/i, category: '読書メモ', tags: ['読書'] },\n    { pattern: /(idea|アイデア|企画|brainstorm)/i, category: 'アイデア', tags: ['アイデア'] },\n    { pattern: /(todo|task|日報|振り返り|学習|メモ)/i, category: '個人メモ', tags: ['メモ'] },\n    { pattern: /(code|開発|python|bug|技術|sql|api)/i, category: '技術メモ', tags: ['技術'] }\n  ];\n\n  for (const rule of rules) {\n    if (rule.pattern.test(text) || rule.pattern.test(pathLower)) {\n      if (Array.isArray(rule.tags)) {\n        rule.tags.forEach(tag => tagsSet.add(tag));\n      }\n      return {\n        category: rule.category,\n        tags: Array.from(tagsSet)\n      };\n    }\n  }\n\n  if (segments.length > 1) {\n    const folder = segments[segments.length - 2] || '未分類';\n    tagsSet.add(folder);\n    return {\n      category: folder,\n      tags: Array.from(tagsSet)\n    };\n  }\n\n  return {\n    category: '未分類',\n    tags: Array.from(tagsSet)\n  };\n};\n\nconst mergeResult = result => {\n  const category = result.category || '未分類';\n  const tags = Array.isArray(result.tags) ? result.tags : [];\n  const uniqueTags = Array.from(new Set(tags.map(tag => String(tag).trim()).filter(Boolean)));\n  return { ...inputData, category, tags: uniqueTags };\n};\n\nif (!apiKey) {\n  return mergeResult(buildFallback());\n}\n\ntry {\n  const response = await $http.post('https://api.openai.com/v1/chat/completions', {\n    model: 'gpt-4o-mini',\n    messages: [\n      {\n        role: 'user',\n        content: `あなたはノート分類の専門家です。以下のノート内容を読んで、適切なカテゴリとタグを提案してください。\\n\\n【カテゴリ候補】\\n- 技術メモ\\n- 読書メモ\\n- アイデア\\n- 会議メモ\\n- 個人メモ\\n\\n【出力形式】\\nJSON形式で返してください:\n{\"category\": \"カテゴリ名\", \"tags\": [\"タグ1\"]}\\n\\nファイル名: ${inputData.fileName}\\n内容: ${inputData.fileContent}`\n      }\n    ],\n    temperature: 0.3,\n    response_format: { type: 'json_object' }\n  }, {\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json'\n    }\n  });\n\n  const content = response.data.choices?.[0]?.message?.content;\n  if (!content) {\n    return mergeResult(buildFallback());\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(content);\n  } catch (parseError) {\n    console.error('OpenAI parse error:', parseError.message);\n    return mergeResult(buildFallback());\n  }\n\n  const fallback = buildFallback();\n  const category = parsed.category || fallback.category;\n  const combinedTags = new Set();\n  (fallback.tags || []).forEach(tag => combinedTags.add(String(tag)));\n  (Array.isArray(parsed.tags) ? parsed.tags : []).forEach(tag => combinedTags.add(String(tag)));\n\n  return {\n    ...inputData,\n    category: category || '未分類',\n    tags: Array.from(combinedTags).map(tag => tag.trim()).filter(Boolean)\n  };\n} catch (error) {\n  console.error('OpenAI API Error:', error.message);\n  return mergeResult(buildFallback());\n}\n",
        "mode": "runOnceForEachItem"
      },
      "id": "59a5e655-822a-43eb-8a26-f47de79df4bd",
      "name": "OpenAI Category Tagging1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        -528
      ]
    },
    {
      "parameters": {
        "jsCode": "// Normalize and pass fields forward\nconst d = $input.item.json;\nreturn { fileName: d.fileName || 'Untitled', fileContent: d.fileContent || '', filePath: d.filePath || '', createdDate: d.createdDate || new Date().toISOString(), category: d.category || '未分類', tags: Array.isArray(d.tags) ? d.tags : [] };",
        "mode": "runOnceForEachItem"
      },
      "id": "27d5cf12-c195-42a6-8ac1-f7a48cd5247f",
      "name": "Parse AI Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -528
      ]
    },
    {
      "parameters": {
  "jsCode": "// Format data for Notion page creation with cleaned metadata\nconst data = $input.item.json;\nconst rawContent = data.fileContent || '';\nconst lines = rawContent.split(/\\r?\\n/);\nconst firstMeaningful = lines.find(line => line.trim().length > 0) || '';\nlet titleCandidate = '';\nif (/^#+\\s+/.test(firstMeaningful)) {\n  titleCandidate = firstMeaningful.replace(/^#+\\s*/, '');\n} else if (firstMeaningful) {\n  titleCandidate = firstMeaningful;\n}\nconst fallbackFromName = (data.fileName || (data.filePath ? data.filePath.split('/').pop() : '') || 'Untitled').replace(/\\.[^.]+$/, '');\nlet cleanedTitle = (titleCandidate || fallbackFromName).replace(/[_-]+/g, ' ').replace(/\\s+/g, ' ').trim();\nif (!cleanedTitle) cleanedTitle = 'Untitled';\nconst relativePath = data.filePath ? data.filePath.replace(/^\\/?notes\\/?/i, '') : '';\nconst folderSegments = relativePath ? relativePath.split('/').slice(0, -1).filter(Boolean) : [];\nconst folderDisplay = folderSegments.join(' / ');\nconst createdDate = data.createdDate || new Date().toISOString();\nconst summary = rawContent.replace(/\\s+/g, ' ').trim().slice(0, 240);\nconst metaLines = [];\nif (folderDisplay) metaLines.push('\u30d5\u30a9\u30eb\u30c0: ' + folderDisplay);\nif (relativePath) metaLines.push('\u30d5\u30a1\u30a4\u30eb: ' + relativePath);\nif (createdDate) metaLines.push('\u4f5c\u6210\u65e5\u6642: ' + createdDate);\nconst paragraphChunks = rawContent.split(/\\r?\\n\\s*\\r?\\n/).map(p => p.trim()).filter(Boolean);\nconst chunkText = (text, size = 1800) => {\n  const out = [];\n  let remaining = text;\n  while (remaining.length > size) {\n    out.push(remaining.slice(0, size));\n    remaining = remaining.slice(size);\n  }\n  if (remaining) out.push(remaining);\n  return out;\n};\nconst children = [];\nif (metaLines.length) {\n  const metaContent = metaLines.join('\\n');\n  children.push({\n    object: 'block',\n    type: 'callout',\n    callout: {\n      icon: { type: 'emoji', emoji: '\ud83d\udcc1' },\n      rich_text: [\n        {\n          type: 'text',\n          text: { content: metaContent }\n        }\n      ]\n    }\n  });\n}\nconst blocks = paragraphChunks.length ? paragraphChunks : [];\nif (!blocks.length && rawContent.trim()) {\n  blocks.push(rawContent.trim());\n}\nif (!blocks.length) {\n  children.push({\n    object: 'block',\n    type: 'paragraph',\n    paragraph: {\n      rich_text: [\n        {\n          type: 'text',\n          text: { content: '\uff08\u672c\u6587\u306a\u3057\uff09' },\n          annotations: { italic: true }\n        }\n      ]\n    }\n  });\n} else {\n  blocks.forEach(paragraph => {\n    const parts = chunkText(paragraph);\n    parts.forEach(part => {\n      children.push({\n        object: 'block',\n        type: 'paragraph',\n        paragraph: {\n          rich_text: [\n            {\n              type: 'text',\n              text: { content: part }\n            }\n          ]\n        }\n      });\n    });\n  });\n}\nconst MAX_BLOCKS = 40;\nif (children.length > MAX_BLOCKS) {\n  children.length = MAX_BLOCKS;\n}\nreturn { title: cleanedTitle, summary, folderDisplay, relativePath, createdDate, content: rawContent, category: data.category || '\u672a\u5206\u985e', tags: Array.isArray(data.tags) ? data.tags.map(t => String(t)) : [], processed: true, filePath: data.filePath || '', children };",
        "mode": "runOnceForEachItem"
      },
      "id": "7be50f9e-5ccc-4500-b652-135982b97b4e",
      "name": "Format for Notion1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -528
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build Notion JSON payload with summary preview and page children\nconst d = $input.item.json;\nconst previewParts = [];\nif (d.summary) previewParts.push('概要: ' + d.summary);\nif (d.folderDisplay) previewParts.push('フォルダ: ' + d.folderDisplay);\nif (d.relativePath) previewParts.push('ファイル: ' + d.relativePath);\nconst preview = previewParts.join(' / ').substring(0, 2000);\nconst properties = {\n  Title: {\n    title: [\n      {\n        type: 'text',\n        text: { content: d.title || 'Untitled' }\n      }\n    ]\n  },\n  Content: {\n    rich_text: [\n      {\n        type: 'text',\n        text: { content: preview || (d.content || '').substring(0, 2000) }\n      }\n    ]\n  },\n  Category: {\n    rich_text: [\n      {\n        type: 'text',\n        text: { content: d.category || '未分類' }\n      }\n    ]\n  },\n  Tags: {\n    multi_select: (Array.isArray(d.tags) ? d.tags : []).map(name => ({ name }))\n  },\n  Processed: {\n    checkbox: d.processed !== false\n  }\n};\nconst notionPayload = {\n  parent: { database_id: '29e1972f485180c89c68d77f1b82e39f' },\n  properties,\n  icon: { type: 'emoji', emoji: '\ud83d\udcdd' }\n};\nif (Array.isArray(d.children) && d.children.length) {\n  notionPayload.children = d.children;\n}\nreturn { notionPayload, filePath: d.filePath || '', __metadata: { filePath: d.filePath || '' } };",
        "mode": "runOnceForEachItem"
      },
      "id": "ffe70d2f-c2a8-4c9e-a40b-c5c0e90b430f",
      "name": "Prepare Notion Data1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -528
      ]
    },
    {
      "parameters": {
        "functionCode": "// Create Notion page with retries to smooth over transient 409 conflicts\nconst payload = $input.item.json?.notionPayload;\nif (!payload) {\n  throw new Error('Missing notionPayload for Notion request');\n}\n\nconst filePath = $input.item.json.filePath || '';\nconst baseKey = `${filePath || 'note'}-${Date.now()}`;\n\nconst buildOptions = (idempotencyKey) => ({\n  method: 'POST',\n  url: 'https://api.notion.com/v1/pages',\n  body: payload,\n  json: true,\n  headers: {\n    'Notion-Version': '2022-06-28',\n    'Idempotency-Key': idempotencyKey\n  }\n});\n\nconst maxAttempts = 3;\nfor (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n  const idempotencyKey = attempt === 0 ? baseKey : `${baseKey}-retry${attempt}`;\n  try {\n    const response = await this.helpers.requestWithAuthentication.call(this, 'notionApi', buildOptions(idempotencyKey));\n    return { ...$input.item.json, notionResponse: response };\n  } catch (error) {\n    const status = error.statusCode ?? error.response?.statusCode ?? error.httpStatusCode;\n    const details = error.response?.body ? JSON.stringify(error.response.body) : error.message;\n    if (status === 409 && attempt < maxAttempts - 1) {\n      const waitMs = 500 * (attempt + 1);\n      await new Promise((resolve) => setTimeout(resolve, waitMs));\n      continue;\n    }\n    throw new Error(`Notion create failed (status ${status ?? 'unknown'}): ${details}`);\n  }\n}\nthrow new Error('Notion create failed after retries');"
      },
      "id": "65453a56-297a-471c-b073-5940cd9ccb5e",
      "name": "Create Notion Page",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [
        64,
        -528
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "filepath-assignment-001",
              "name": "filePath",
              "value": "={{ $json.filePath }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "525a4f4b-1c75-47f5-82a9-1739f038be69",
      "name": "Pass FilePath1",
      "type": "n8n-nodes-base.set",
  "typeVersion": 3,
      "position": [
        256,
        -528
      ]
    },
    {
      "parameters": {
        "command": "=echo \"{{ $json.filePath }}\" >> /notes/.processed_files.txt"
      },
      "id": "0da6c338-8f5a-4a79-ab31-bde963d14e1b",
      "name": "Mark As Processed1",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        448,
        -528
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Old File Check": {
      "main": [
        [
          {
            "node": "Delete Old File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily Reminder Cron": {
      "main": [
        [
          {
            "node": "Get All Notes from Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Notes from Notion": {
      "main": [
        [
          {
            "node": "Random Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger1": {
      "main": [
        [
          {
            "node": "List All Files1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Processed List1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List All Files1": {
      "main": [
        [
          {
            "node": "Filter Unprocessed Files1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Processed List1": {
      "main": [
        [
          {
            "node": "Filter Unprocessed Files1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Unprocessed Files1": {
      "main": [
        [
          {
            "node": "Read Note File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Note File1": {
      "main": [
        [
          {
            "node": "Set Note Metadata1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Note Metadata1": {
      "main": [
        [
          {
            "node": "OpenAI Category Tagging1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Old File Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Category Tagging1": {
      "main": [
        [
          {
            "node": "Parse AI Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response1": {
      "main": [
        [
          {
            "node": "Format for Notion1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Notion1": {
      "main": [
        [
          {
            "node": "Prepare Notion Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Notion Data1": {
      "main": [
        [
          {
            "node": "Create Notion Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Notion Page": {
      "main": [
        [
          {
            "node": "Pass FilePath1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass FilePath1": {
      "main": [
        [
          {
            "node": "Mark As Processed1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "executionTimeout": 60,
    "availableInMCP": false,
    "timeSavedPerExecution": 1,
    "timezone": "Asia/Tokyo",
    "errorWorkflow": "8u1A7FkVxvdQ7ddq"
  },
  "versionId": "31baaf16-3b02-4a60-bd56-c45a2217ea38",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "50e903defc9d1e319ece6676f15d8b344337224bc62b9de3cc8418f0c564705c"
  },
  "id": "8u1A7FkVxvdQ7ddq",
  "tags": []
}
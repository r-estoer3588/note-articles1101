{
  "name": "Notes to Notion Auto Organizer (Schedule Fixed - Expanded)",
  "nodes": [
    {
      "parameters": { "rule": { "interval": [ { "minutesInterval": 5 } ] } },
      "id": "schedule-trigger-001",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [-240, 0]
    },
    {
      "parameters": {
        "command": "find /notes -maxdepth 1 -type f \\ ( -name \"*.txt\" -o -name \"*.md\" \\ ) ! -name \".processed_files.txt\""
      },
      "id": "list-files-node-001",
      "name": "List All Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [-48, 0]
    },
    {
      "parameters": {
        "command": "touch /notes/.processed_files.txt && cat /notes/.processed_files.txt"
      },
      "id": "get-processed-list-001",
      "name": "Get Processed List",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [-48, 120]
    },
    {
      "parameters": {
        "jsCode": "// Filter out already processed files\n// This node receives data from BOTH List All Files and Get Processed List\nconst allInputs = $input.all();\nlet allFilesOutput = '';\nlet processedListOutput = '';\nfor (const item of allInputs) {\n  const stdout = item.json?.stdout || '';\n  if (stdout.includes('/notes/')) {\n    if (stdout.split('\\n').filter(Boolean).length > 1 || !processedListOutput) {\n      allFilesOutput = stdout;\n    } else if (!allFilesOutput) {\n      processedListOutput = stdout;\n    }\n  } else if (!processedListOutput) {\n    processedListOutput = stdout;\n  }\n}\nif (!allFilesOutput.trim()) { return []; }\nconst allFiles = allFilesOutput.split('\\n').map(s => s.trim()).filter(Boolean);\nconst processedFiles = processedListOutput ? processedListOutput.split('\\n').map(s => s.trim()).filter(Boolean) : [];\nconst processedSet = new Set(processedFiles);\nunprocessedFiles = allFiles.filter(f => !processedSet.has(f));\nif (unprocessedFiles.length === 0) { return []; }\nreturn unprocessedFiles.map(file => ({ json: { path: file, fileName: file.split('/').pop() } }));"
      },
      "id": "filter-unprocessed-001",
      "name": "Filter Unprocessed Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [336, 0]
    },
    {
      "parameters": { "filePath": "={{ $json.path }}", "options": {} },
      "id": "read-file-001",
      "name": "Read Note File",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [528, 0]
    },
    {
      "parameters": {
        "jsCode": "// Extract text robustly (UTF-8 first, fallback to Shift_JIS if supported) and use actual file mtime\nconst fs = require('fs');\nconst item = $input.item;\nconst path = item.json.path;\nconst fileName = (item.json.fileName || (path ? path.split('/').pop() : 'Untitled'));\nlet createdDate = new Date().toISOString();\ntry { const st = fs.statSync(path); createdDate = new Date(st.mtimeMs).toISOString(); } catch (_) {}\nlet fileContent = '';\nconst decodeUtf8 = (buf) => { try { const td = new TextDecoder('utf-8', { fatal: false }); return td.decode(buf); } catch { return buf.toString('utf8'); } };\nconst maybeDecodeShiftJis = (buf) => { try { const td = new TextDecoder('shift_jis'); return td.decode(buf); } catch { return null; } };\nconst looksLikeMojibake = (s) => { if (!s) return false; const rep = (s.match(/\\uFFFD/g) || []).length; const len = s.length || 1; const garble = /(ã‚|ã|ã€|å|é|ï¼)/.test(s); return rep / len > 0.02 || garble; };\nif (item.binary) {\n  let base64Str = '';\n  if (typeof item.binary.data === 'string') base64Str = item.binary.data;\n  else if (item.binary.data && typeof item.binary.data.data === 'string') base64Str = item.binary.data.data;\n  else { const firstKey = Object.keys(item.binary)[0]; const entry = item.binary[firstKey]; if (entry && typeof entry.data === 'string') base64Str = entry.data; else if (entry && entry.data && typeof entry.data.data === 'string') base64Str = entry.data.data; }\n  if (base64Str) { try { const buf = Buffer.from(base64Str, 'base64'); let text = decodeUtf8(buf); if (looksLikeMojibake(text)) { const sjis = maybeDecodeShiftJis(buf); if (sjis && !looksLikeMojibake(sjis)) { text = sjis; } } fileContent = text; } catch (e) { fileContent = base64Str; } }\n}\nreturn { fileName, fileContent, filePath: path, createdDate };"
      },
      "id": "set-note-metadata-001",
      "name": "Set Note Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [736, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [ { "id": "old-check-001", "leftValue": "={{ $now.minus({ days: 30 }).toMillis() }}", "rightValue": "={{ new Date($json.createdDate).getTime() }}", "operator": { "type": "number", "operation": "gt" } } ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "old-file-check-001",
      "name": "Old File Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [736, 208]
    },
    {
      "parameters": { "command": "=rm -f \"{{ $json.filePath }}\"" },
      "id": "delete-old-file-001",
      "name": "Delete Old File",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [944, 208]
    },
    {
      "parameters": {
        "jsCode": "// Use OpenAI via HTTP with API key from env\nconst apiKey = $env.OPENAI_API_KEY;\n\nif (!apiKey) {\n  return { ...$input.item.json, category: '未分類', tags: [] };\n}\n\nconst inputData = $input.item.json;\n\nconst prompt = `あなたはノート分類の専門家です。以下のノート内容を読んで、適切なカテゴリとタグを提案してください。\n\n【カテゴリ候補】\n- 技術メモ\n- 読書メモ\n- アイデア\n- 会議メモ\n- 個人メモ\n\n【出力形式】\nJSON形式で返してください:\n{\"category\": \"カテゴリ名\", \"tags\": [\"タグ1\"]}\n\nファイル名: ${inputData.fileName}\n内容: ${inputData.fileContent}`;\n\ntry {\n  const response = await $http.post('https://api.openai.com/v1/chat/completions', {\n    model: 'gpt-4o-mini',\n    messages: [\n      { role: 'user', content: prompt }\n    ],\n    temperature: 0.3,\n    response_format: { type: 'json_object' }\n  }, {\n    headers: {\n      'Authorization': `Bearer ${apiKey}`,\n      'Content-Type': 'application/json'\n    }\n  });\n\n  const content = response.data.choices[0].message.content;\n  const parsed = JSON.parse(content);\n\n  return {\n    ...inputData,\n    category: parsed.category || '未分類',\n    tags: Array.isArray(parsed.tags) ? parsed.tags : []\n  };\n} catch (error) {\n  console.error('OpenAI API Error:', error.message);\n  return {\n    ...inputData,\n    category: '未分類',\n    tags: []\n  };\n}"
      },
      "id": "openai-category-001",
      "name": "OpenAI Category Tagging",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [944, 0]
    },
    {
      "parameters": { "jsCode": "const d = $input.item.json; return { fileName: d.fileName || 'Untitled', fileContent: d.fileContent || '', filePath: d.filePath || '', createdDate: d.createdDate || new Date().toISOString(), category: d.category || '未分類', tags: Array.isArray(d.tags) ? d.tags : [] };" },
      "id": "parse-ai-response-001",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1152, 0]
    },
    {
      "parameters": { "jsCode": "const data = $input.item.json; let tags = []; if (Array.isArray(data.tags)) tags = data.tags.map(t => String(t)); else if (data.tags) tags = [String(data.tags)]; return { title: (data.fileName || data.filePath?.split('/').pop() || 'Untitled').replace(/\\.(txt|md)$/i, ''), content: data.fileContent || '', category: data.category || '未分類', tags, processed: true, filePath: data.filePath || '' };" },
      "id": "format-for-notion-001",
      "name": "Format for Notion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 0]
    },
    {
      "parameters": { "jsCode": "const d = $input.item.json; const notionPayload = { parent: { database_id: '29e1972f485180c89c68d77f1b82e39f' }, properties: { title: { title: [ { text: { content: d.title || 'Untitled' } } ] }, Content: { rich_text: [ { text: { content: (d.content || '').substring(0, 2000) } } ] }, Category: { rich_text: [ { text: { content: d.category || '未分類' } } ] }, Tags: { multi_select: (d.tags || []).map(t => ({ name: String(t) })) }, Processed: { checkbox: d.processed || true } } }; return { notionPayload, filePath: d.filePath || '', __metadata: { filePath: d.filePath || '' } };" },
      "id": "prepare-notion-data-001",
      "name": "Prepare Notion Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1552, 0]
    },
    {
      "parameters": { "method": "POST", "url": "https://api.notion.com/v1/pages", "authentication": "predefinedCredentialType", "nodeCredentialType": "notionApi", "sendBody": true, "specifyBody": "json", "jsonBody": "={{ JSON.stringify($json.notionPayload) }}", "options": { "response": { "response": { "neverError": false, "responseFormat": "json", "outputPropertyName": "notionResponse" } } } },
      "id": "create-notion-page-http-001",
      "name": "Create Notion Page (HTTP)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1744, 0],
      "credentials": { "notionApi": { "id": "nsXTOjwR6MmTqoxn", "name": "Notion account" } }
    },
    {
      "parameters": { "assignments": { "assignments": [ { "id": "filepath-assignment-001", "name": "filePath", "value": "={{ $json.filePath }}", "type": "string" } ] }, "options": {} },
      "id": "set-filepath-001",
      "name": "Pass FilePath",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1936, 0]
    },
    {
      "parameters": { "command": "=echo \"{{ $json.filePath }}\" >> /notes/.processed_files.txt" },
      "id": "mark-processed-001",
      "name": "Mark As Processed",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2128, 0]
    },
    {
      "parameters": { "rule": { "interval": [ { "field": "hours" } ] } },
      "id": "daily-reminder-cron-001",
      "name": "Daily Reminder Cron",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [-240, 400]
    },
    {
      "parameters": { "resource": "databasePage", "operation": "getAll", "databaseId": { "__rl": true, "value": "29e1972f485180c89c68d77f1b82e39f", "mode": "id" }, "returnAll": true, "options": {} },
      "id": "get-all-notes-001",
      "name": "Get All Notes from Notion",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [-48, 400],
      "credentials": { "notionApi": { "id": "nsXTOjwR6MmTqoxn", "name": "Notion account" } }
    },
    {
      "parameters": { "jsCode": "const items = $input.all(); if (!items.length) { return { message: 'No notes found' }; } const randomIndex = Math.floor(Math.random() * items.length); const randomNote = items[randomIndex].json; return { title: randomNote.properties?.Title?.title?.[0]?.plain_text || 'No title', url: randomNote.url, category: randomNote.properties?.Category?.rich_text?.[0]?.plain_text || '未分類' };" },
      "id": "random-reminder-001",
      "name": "Random Reminder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [144, 400]
    }
  ],
  "connections": {
    "Schedule Trigger": { "main": [ [ { "node": "List All Files", "type": "main", "index": 0 }, { "node": "Get Processed List", "type": "main", "index": 0 } ] ] },
    "List All Files": { "main": [ [ { "node": "Filter Unprocessed Files", "type": "main", "index": 0 } ] ] },
    "Get Processed List": { "main": [ [ { "node": "Filter Unprocessed Files", "type": "main", "index": 0 } ] ] },
    "Filter Unprocessed Files": { "main": [ [ { "node": "Read Note File", "type": "main", "index": 0 } ] ] },
    "Read Note File": { "main": [ [ { "node": "Set Note Metadata", "type": "main", "index": 0 } ] ] },
    "Set Note Metadata": { "main": [ [ { "node": "OpenAI Category Tagging", "type": "main", "index": 0 }, { "node": "Old File Check", "type": "main", "index": 0 } ] ] },
    "Old File Check": { "main": [ [ { "node": "Delete Old File", "type": "main", "index": 0 } ] ] },
    "OpenAI Category Tagging": { "main": [ [ { "node": "Parse AI Response", "type": "main", "index": 0 } ] ] },
    "Parse AI Response": { "main": [ [ { "node": "Format for Notion", "type": "main", "index": 0 } ] ] },
    "Format for Notion": { "main": [ [ { "node": "Prepare Notion Data", "type": "main", "index": 0 } ] ] },
    "Prepare Notion Data": { "main": [ [ { "node": "Create Notion Page (HTTP)", "type": "main", "index": 0 } ] ] },
    "Create Notion Page (HTTP)": { "main": [ [ { "node": "Pass FilePath", "type": "main", "index": 0 } ] ] },
    "Pass FilePath": { "main": [ [ { "node": "Mark As Processed", "type": "main", "index": 0 } ] ] },
    "Daily Reminder Cron": { "main": [ [ { "node": "Get All Notes from Notion", "type": "main", "index": 0 } ] ] },
    "Get All Notes from Notion": { "main": [ [ { "node": "Random Reminder", "type": "main", "index": 0 } ] ] }
  },
  "active": false,
  "settings": { "executionOrder": "v1", "callerPolicy": "workflowsFromSameOwner", "executionTimeout": -1, "availableInMCP": false, "timezone": "Asia/Tokyo" },
  "versionId": "schedule-fixed-expanded-001",
  "meta": { "templateCredsSetupCompleted": true },
  "tags": []
}
